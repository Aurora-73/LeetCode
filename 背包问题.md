## 1. 0-1 背包（0-1 Knapsack）

**问题描述**

* 有 **N** 件物品，第 *i* 件物品重量为 `w[i]`、价值为 `v[i]`；
* 一个容量为 **C** 的背包；
* 每件物品最多选 1 次，求在不超过容量的前提下，使背包中物品总价值最大化。

**状态定义**

* `dp[i][j]`：前 *i* 件物品、当前背包容量为 *j* 时的最大价值。

**状态转移**

```
dp[i][j] = max(
  dp[i-1][j],                  // 不选第 i 件
  dp[i-1][j - w[i]] + v[i]     // 选第 i 件（前提 j >= w[i]）
)
```

**初始化**

```
dp[0][j] = 0    // 0 件物品时，价值为 0
dp[i][0] = 0    // 容量为 0 时，价值为 0
```

**复杂度**

* 时间：O(N·C)
* 空间：O(N·C) （可滚动数组优化到 O(C)）

## 2. 完全背包（Unbounded Knapsack）

**问题描述**

* 与 0-1 背包类似，但每件物品可无限次选取（只受容量约束）。

**状态定义**

* `dp[j]`：当前背包容量为 *j* 时的最大价值（一般只用一维数组）。

**状态转移**
对于每件物品 `i`：

```
for j = w[i] … C:          // 注意 j 从前往后
    dp[j] = max(dp[j], dp[j - w[i]] + v[i])
```

**解释**

* “完全”意味着选过第 *i* 件后，仍可继续在剩余容量 `j - w[i]` 中再次选第 *i* 件。

**复杂度**

* 时间：O(N·C)
* 空间：O(C)

## 3. 多重背包（Bounded Knapsack）

**问题描述**

* 每件物品 `i` 有数量限制 `cnt[i]`（>1），其余同 0-1 背包。

**常见做法**

1. **二进制拆分**：将 `cnt[i]` 拆成若干 1、2、4… 段，转化为若干 0-1 项。
2. **直接三重循环**（不推荐）：
   ```
   for i in 1…N:
     for k in 1…cnt[i]:
       for j = C … w[i]:
         dp[j] = max(dp[j], dp[j - w[i]] + v[i])
   ```

**二进制拆分后状态转移**
拆分后总项数 ≈ O(∑ log cnt[i])，再用 0-1 背包方法计算。

## 4. 分组背包（Grouped Knapsack）

**问题描述**

* N 件物品划分为若干组，同一组中最多只能选 **1** 件；
* 背包容量 C，求最大价值。

**状态定义**

* `dp[j]`：容量 *j* 时的最大价值。

**状态转移**

```
for each 组 g:
  for j = C down to 0:
    for each 物品 i in 组 g:
      if j >= w[i]:
        dp[j] = max(dp[j], dp[j - w[i]] + v[i])
```

## 5. 分数背包（Fractional Knapsack）

**问题描述**

* 物品可以按任意比例拆分；
* 求在容量 C 下使总价值最大。

**贪心策略**

1. 计算每件物品 “单位重量价值” = `v[i] / w[i]`。
2. 按单位价值从高到低排序，尽量多装高价值物品；
3. 若剩余容量不足以装下下一整件，则只装部分。

**复杂度**

* 时间：O(N·log N)（排序）

## 6. 二维/多维背包（Multi-dimension Knapsack）

**问题描述**

* 除了重量 `w[i]`，可能还有体积、体积、时间等多种资源限制；
* 容量为 `C1, C2, …, CK`。

**状态定义**

* `dp[j1][j2]…[jK]`：每个维度的容量分别为 `j1, j2, …, jK` 时的最大价值。

**状态转移**
与 0-1 背包类似，但循环多维，复杂度指数增长，通常 K≤2、容量较小时可行。

## 7. 多重背包的特殊扩展

* **Group + Bounded**：物品有组限和数量限；
* **依赖背包**（Tree Knapsack）：物品间有依赖关系（树状），选子节点需选父节点。
* **多背包（Multiple Knapsacks）**：有多个背包，如何分配物品。

### 总结对比


| 类型     | 可选次数       | 算法思路                  | 复杂度                 |
| -------- | -------------- | ------------------------- | ---------------------- |
| 0-1 背包 | 0 或 1         | 二维/一维 dp              | O(N·C)                |
| 完全背包 | 无限次         | 一维 dp（j 正序）         | O(N·C)                |
| 多重背包 | 有限（cnt[i]） | 二进制拆分 + 0-1/backpack | O(N·C·log C)≈O?     |
| 分组背包 | 组内选 0/1     | 组外循环 + 组内循环       | O(组数 · C · 组大小) |
| 分数背包 | 可拆分         | 贪心                      | O(N·log N)            |
| 二维背包 | 0/1 或无限     | 多维数组 dp               | O(N·∏Ci)             |

以上为常见背包问题的详细分类与基本解法。如果需要示例代码或特定变种的深入讲解，欢迎告诉我！
