1、链表快慢指针：

* **环形链表（判环／找环入口）**
  一定要让 `slow = head; fast = head;`，并且用「先移动再判断是否相遇」的方式。这样逻辑最简洁、最不容易出错。
* **找链表中点**
  * 如果偶数长度时想取 **右中点**，就 `fast = head;`。
  * 如果想取 **左中点**，就 `fast = head->next;`。

2、如果要用 key 只有小写字母的哈希表，则不需要哈希表，直接用长为 26 的数组即可

3、char可以表示 2⁸＝256 种不同的取值，范围是0～255 或者 –128～127。但是ASCII码只有128种，且一定是0 - 127。

4、 $(x \,\circ\, y) \bmod m \;=\;\bigl((x \bmod m)\,\circ\,(y \bmod m)\bigr)\bmod m    \quad(\circ=+,-,×)$

5、获取测试数据

```
vector<string> param_names = {"param1", "param2"};
std::vector<std::string> lines;
for (std::string line; std::getline(std::cin, line);)
    lines.push_back(line);
int i = 0, n = lines.size();
while(i < n){
    for(auto &name : param_names){
        cout << name << " = " << lines[i] << ';' << endl;;
        ++i;
    }
    cout << endl;
}
```

6、二分查找 寻找第一个\最后一个xxx的元素 最简单的写法：

```
template <typename Cond>
int find_first(const vector<int> &vec, Cond cond) {
	int left = 0, right = vec.size(); // 左开右闭
	while(left < right) {
		int mid = left + (right - left) / 2;
		bool curr = cond(vec[mid]);
		if(curr) {
			// 额外判断当前的前一个
			bool prev = mid > 0 ? cond(vec[mid - 1]) : 0;
			if(!prev) {
				return mid; // 找到第一个 true
			} else {
				right = mid; // true，但不是第一个，向左收缩
			}
		} else {
			left = mid + 1; // false，答案在右边
		}
	}
	return left;
} // 额外判断当前是不是第一个，更容易写
```
